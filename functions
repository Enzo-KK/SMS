# подключаемые функции 
# база 
# getpu.acc_indication
# поля
# nom l_chet n_elec elec n_hv1 hv1 n_gv1 gv1 n_hv2 hv2 n_gv2 gv2 n_hv3 hv3 n_gv3 gv3 n_hv4 hv4 n_gv4 gv4 phone email

# описываем соединение с сервером MySQL, и принимаем первым аргументом нужные команды
connect () {
mysql -D getpu -u sms_acc -p1313 -Bse "$1"
}

# формирование правильного файла хмл 
mak_gud_xml() {
	# правим хмл файл
	# сначала меняем русский 
	#sed -e 's/<Раздел/<razdel/g' short > short1
	sed -e 's/<Раздел/<razdel/g' 08_IPK.xml > short1
	sed -e 's/<\/Раздел/<\/razdel/g' short1 > short2
	sed -e 's/<Строка/<string/g' short2 > short1
	sed -e 's/<\/Строка/<\/string/g' short1 > short0
	# теперь правим разделы
	# множественные строки данных включены в раздел 2, а все вместе в раздел 1
	# т.о. мы и адрес пропишем в таблицу показаний для идентификации по объекту недвижимости
	sed -e 's/<\/razdel2>//g' short0 > short1
	sed -e 's/<razdel3>//g' short1 > short2
	sed -e 's/<\/razdel3>//g' short2 > short1
	sed -e 's/<razdel4>//g' short1 > short2
	sed -e 's/<\/razdel1>//g' short2 > short1
	sed -e 's/<razdel2>/<razdel4>/g' short1 > short2
	sed -e 's/<razdel5\/>/<\/razdel1>/g' short2 > all_ipk.xml
	cp all_ipk.xml /var/lib/mysql-files/
}

# загрузка хмл в базу данных
fill_base () {
	connect "LOAD XML INFILE '/var/lib/mysql-files/all_ipk.xml' INTO TABLE person ROWS IDENTIFIED BY '<razdel1>';"
	connect "LOAD XML INFILE '/var/lib/mysql-files/all_ipk.xml' INTO TABLE money ROWS IDENTIFIED BY '<razdel4>';"
	connect "LOAD XML INFILE '/var/lib/mysql-files/all_ipk.xml' INTO TABLE data_indic ROWS IDENTIFIED BY '<string>';"
}

# основная функция обработки
# передаются параметрами: $lsch $ele $hov $gov $from

exch_bd(){
# получаем из строк только значения показаний
local lc=$1
local el_new=$2
local hv_new=$3
local gv_new=$4
# с телефоном не определился.. отслеживать или нет соответствие
local fr=$5
local fn=$6

# преобразуем в значение с плавающей точкой
el_new=${el_new/,/.}
hv_new=${hv_new/,/.}
gv_new=${gv_new/,/.}

# проверка принятых показаний
# echo "data: $lc $el $ho $go" 
	###############
	# сначала проверяем сколько у чела квартир, если больше одной - футболим
	moreone=$(connect "select count(*) from person where person.КодЛицевогоСчета like '$lc'") ; 
	if [[ $moreone>1 ]]; then
		send_error "Невозможно принять показания.\nОбратитесь в офис УК." $fr
		exit 0
	fi
	###############
	# проверяем отправлены хоть какие то значения
	is_data=$(echo "$el_new+$hv_new+$gv_new" | bc)
	if [[ $(echo "${is_data} == 0" | bc) -eq 1 ]]; then
		#echo -e "data: $lc $el_new $hv_new $gv_new\n" > /home/constantin/sms/err/is_data
		#echo -e "all: $is_data" >> /home/constantin/sms/err/is_data
		send_error "В полученном СМС нулевые показания." $fr
		exit 0
	fi
	##############
	# теперь проверяем корректность значений
	# result=$(connect "select l_chet, elec, hv1, gv1 from acc_indication where l_chet like '$lc'") ; 
	
	result=$(connect "select p.КодЛицевогоСчета, p.ФИОСобственника, p.Адрес, i.НаименованиеУслуги, i.Потребление 
		from person p, data_indic i where p.КодЛицевогоСчета = i.НомерЛицевогоСчета and p.КодЛицевогоСчета = '$lc' 
		and i.Потребление>0 and (i.НаименованиеУслуги = 'Электроэнергия' or i.НаименованиеУслуги = 'Холодное водоснабжение (счетчик)' 
		or i.НаименованиеУслуги = 'Горячее водоснабжение (счетчик)')");
	
#	 echo "result: $result"

	 # проверка результата запроса
	 lns=${#result}
#	 echo "lengh=$lns"
	# если результат пустой- лицевого в базе нет
	# if [ -z $result ]; then
	if [[ $lns<1 ]]; then
		# echo "добавляем запись"
		# добавляем записи в базу
		# connect "insert into acc_indication(l_chet, elec, hv1, gv1, phone) values($lc, $el, $ho, $go, $fr)";
		connect "insert into person(КодЛицевогоСчета, Телефон) values($lc, $fr)";
		connect "insert into data_indic(НомерЛицевогоСчета, НаименованиеУслуги, Потребление) values($lc, 'Электроэнергия', $el_new)";
		connect "insert into data_indic(НомерЛицевогоСчета, НаименованиеУслуги, Потребление) 
		values($lc, 'Холодное водоснабжение (счетчик)', $hv_new)";
		connect "insert into data_indic(НомерЛицевогоСчета, НаименованиеУслуги, Потребление) 
		values($lc, 'Горячее водоснабжение (счетчик)', $gv_new)";
	else
		echo "проверяем показания"

### получаем значения из данных запроса
		el_old=`echo -e "$result" | grep "Электроэнергия"`
		el_old=${el_old: -15}
		el_old=`echo "$el_old" | cut -d "я" -f 2`
	# преобразуем в значение с плавающей точкой
		el_old=${el_old/,/.}

		hv_old=`echo -e "$result" | grep "Холодное"`
		hv_old=${hv_old: -15}
		hv_old=`echo "$hv_old" | cut -d ")" -f 2`
		hv_old=${hv_old/,/.}

		gv_old=`echo -e "$result" | grep "Горячее"`
		gv_old=${gv_old: -15}
		gv_old=`echo "$gv_old" | cut -d ")" -f 2`
		gv_old=${gv_old/,/.}

# тут извлекаем максимальные данные изменений из файла max_data.dat
		max_el=`grep -e "Электро:" /home/constantin/sms/max_data.dat | formail -zx Электро:`
		max_hv=`grep -e "ХВС:" /home/constantin/sms/max_data.dat | formail -zx ХВС:`
		max_gv=`grep -e "ГВС:" /home/constantin/sms/max_data.dat | formail -zx ГВС:`

# операции с плавающей точкой только через калькулятор
		sum_el=$(echo "$el_old+$max_el" | bc)
		sum_hv=$(echo "$hv_old+$max_hv" | bc)
		sum_gv=$(echo "$gv_old+$max_gv" | bc)

# и сверяем принятые показания с ними или проверяем чтобы показания не были меньше учтеных
		#if [[ $(echo "${el_new} < ${el_old}" | bc) -eq 1  ||  $(echo "${hv_new} < ${hv_old}" | bc) -eq 1  
		#||  $(echo "${gv_new} < ${gv_old}" | bc) -eq 1 ]] 
		
		# делаем раздельную проверку показаний
		if [[ $el_new == 0 || $(echo "${el_new} < ${el_old}" | bc) -eq 1  ||  $(echo "${el_new} > ${sum_el}" | bc) -eq 1 ]] 
		then
			# электроэнергию не принимаем
			echo "нет электроэнергии: $el_new."
			el_new=0
			#el_err='ЭЛ'
		fi
		if [[ $hv_new == 0 || $(echo "${hv_new} < ${hv_old}" | bc) -eq 1  ||  $(echo "${hv_new} > ${sum_hv}" | bc) -eq 1 ]] 
		then
			# холодную воду не принимаем
			hv_new=0
			#hv_err='ХВ'
		fi
		if [[ $gv_new == 0 || $(echo "${gv_new} < ${gv_old}" | bc) -eq 1  ||  $(echo "${gv_new} > ${sum_gv}" | bc) -eq 1 ]] 
		then
			# горячую воду не принимаем
			gv_new=0
			#gv_err='ГВ'
		fi
#			send_error "Отправлены неверные данные!\nПоказания меньше поданных вами ранее!" $fr

#### перенес из основного скрипта сюда
		no_in=""
		str_out_sms="ЛС:$lc;"
		str_out=";;;;Лицевой счет:$lc;"
		if [[ $el_new != 0 ]]; then
			str_out_sms="$str_out_smsЭЛ:$2;"
			str_out="$str_outТип прибора:Электро;;Показания:$2;"
		else
			no_in="ЭЛ;"
		fi
		if [[ $hv_new != 0 ]]; then
			str_out_sms="$str_out_smsХВ:$3;"
			str_out="$str_outТип прибора:ХВС;;Показания:$3;"
		else
			no_in="$no_inХВ;"
		fi
		if [[ $gv_new != 0 ]]; then
			str_out_sms="$str_out_smsГВ:$4"
			str_out="$str_outТип прибора:ГВС;;Показания:$4;"
		else
			no_in="$no_inГВ"
		fi

		echo -e "От вас поступили показания:\n$str_out_sms" > /var/spool/sms/conv/mes$fn
		# если есть неверные
		if [[ $el_new == 0 || $hv_new == 0 || $gv_new == 0 ]]; then
			echo -e "Не приняты: $no_in" >> /var/spool/sms/conv/mes$fn
		fi
		echo -e "To: $fr\nAlphabet: UCS2\n" > /var/spool/sms/conv/$fn
  		iconv -f UTF-8 -t UCS-2BE /var/spool/sms/conv/mes$fn >> /var/spool/sms/conv/$fn
  		mv /var/spool/sms/conv/$fn /var/spool/sms/outgoing/
  		
  		####### чтоб не отправлять пока. проверочный вариант
  		# mv /var/spool/sms/conv/$fn /home/constantin/sms/chk/
  		# chmod a+r /home/constantin/sms/chk/$fn
  		# exit 0
  		########
  		
  		message="$str_out;Контактный телефон:+$fr;;"
  		echo "$message" > /home/constantin/sms/tomail/$fn
  		rm /var/spool/sms/conv/mes$fn
		# разрешаем всем читать смс
  		chmod a+r /home/constantin/sms/tomail/$fn
  		# отправка на почту почему то не работает 
  		
  		# и здесь отправка дубля показаний на эл.почту, пока отключил
  		# echo -e "$message" | mail -s -r ck@onlight.pro "Incoming SMS from +$from" in@vivaluks.ru
  		# отправка в лог
  		echo -e "$(date)\n$message\n" >> /var/log/smsd/sms_snt.log
    	# на фтп не вкуриваются пути, только имя файла
  		cd /home/constantin/sms/tomail
  		ftp -in -u ftp://j880085_wp3:shE6Wctw58Q@159dz.spectrum.myjino.ru/site/getpu/inSMS/ $fn
#######
		
		# заменяем имеющиеся данные
		# кстати, а если отправил данные другой чел ошибшись лицевым..
		# наверно следует сделать проверку на занесенный телефон

#		echo "Все путем! делаем апдейт записи"

		# записываем новые показания в бд
#		пока не буду записывать. если не одна запись по показаниям не туда можно записать
		# connect "update acc_indication set elec=$el_new, hv1=$hv_new, gv1=$gv_new where l_chet like '$lc'";
		
	#	connect "update data_indic set Потребление=$el_new where НомерЛицевогоСчета = '$lc' and НаименованиеУслуги = 'Электроэнергия' and Потребление>0";
	#	connect "update data_indic set Потребление=$hv_new where НомерЛицевогоСчета = '$lc' and НаименованиеУслуги = 'Холодное водоснабжение (счетчик)'";
	#	connect "update data_indic set Потребление=$gv_new where НомерЛицевогоСчета = '$lc' and НаименованиеУслуги = 'Горячее водоснабжение (счетчик)'";
	fi
}

# отправка смс об ошибке. сообщение и номер тел. передаются параметрами
send_error()
{
	local err=$1
	local phn=$2
	# код ошибки 0 неверное
	# local met=$3
	# FILE=`mktemp /tmp/sms_erm_XXXXXX`
	FILE1=`mktemp /tmp/sms_err.XXXXXX`
	day=$(date)
	day=${day:7:2}
		# проверяем отправляли ли челу уже смс
		if ( grep -i $phn /home/constantin/sms/nomera.dat > /dev/null ); then
      		#уже отправляли смс
      		exit 0
      	else
      		# проверка по диапазону дат приема показаний
      		if (( $phn != '79647407381' )); then
      			if (( $day < 20 || $day > 25 )); then
      				exit 0
      			fi
      		fi
      		echo "$phn" >> /home/constantin/sms/nomera.dat
    	fi
		# сначала кладем во времменый каталог для преобразования
		#echo -e "$err" > /var/spool/sms/conv/err_mess.sms
		#echo -e "$err" > FILE
		# нафига! все делаем зараз
    	echo -e "To: $phn\nAlphabet: UCS2\n" > $FILE1
    	echo -e "$err" | iconv -f UTF-8 -t UCS-2BE >> $FILE1
    	mv $FILE1 /var/spool/sms/outgoing/
   		# пока сюда
   		# mv /home/constantin/sms/conv/send_er_ind.sms /home/constantin/sms/
   		# ответ на ошибку в лог
   		echo -e "$(date)\n$phn\n$err\n" >> /var/log/smsd/sms_err.log	
}

# варианты кода

# пробный запрос. все путем!
sel-rec(){
	result=$(connect "select l_chet, elec, hv1, gv1 from acc_indication where l_chet like '$1'") ; 
	echo $result;
}

# чтобы использовать этот, должно быть точное количество разделительных пробелов

# sqlget='select id, code, name, brand  from table where id="'$id'"';
#  result=$(mysql -h$host -u $dbuser -p$dbpass $db -e "$sqlget" -N -s);
#      echo $result;
#      code=$(echo $result | cut -d " " -f 2);
#      name=$(echo $result | cut -d " " -f 3);
#      brand=$(echo $result | cut -d " " -f 4);

# Улица:м-н Березовый;Дом:28;Квартира:3.1;ФИО:;Лицевой счет:45645644;Тип прибора:Электро;Серийный  
# номер:jk;Показания:67.6;Тип прибора:ХВС;Серийный номер:gh;Показания:456;Тип прибора:ГВС;Серийный 
# номер:hg;Показания:678;Контактный телефон:+77777777777;E-mail:ff@jj.com;

# проверка работы скрипта
chck-arg () {
echo "param: ${1} ${2} ${3} ${4} ${5}" 
# получаем из строк только значения показаний
local lc=$1
local el=$2
local ho=$3
local go=$4
# с телефоном не определился.. отслеживать или нет соответствие
local fr=$5
echo "data: $lc $el $ho $go $fr" 
}
